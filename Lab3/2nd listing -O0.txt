gcc 10.2 -O0 -S -m32

LeibnizFormula(int):            # Начало функции LeibnizFormula
        pushl   %ebp            # Сохранить указатель кадра вызвавшей программы
        movl    %esp, %ebp      # Создать новый стек (база нового стека =  вершина прошлого стека)
        subl    $56, %esp       # Сместить вершину стека на 56 байта вперед - зарезервировать место под локальные переменные
        fldz                    # Загрузить число 0.0
        fstpt   -20(%ebp)       # Записать и вытолкнуть вещественное число pi = 0.0
        movl    $0, -24(%ebp)   # Записать по адресу -24(%ebp) значение $0(int i = 0)
.L3:                            
        movl    -24(%ebp), %eax # Записать в %eax значение из памяти (переменная i)
        cmpl    8(%ebp), %eax   # Сравнить значение из памяти (n) и %eax (i < n)
        jge     .L2             # Переход, если больше или равно
        movl    -24(%ebp), %eax # Записать в %eax значение из памяти (переменная i)
        addl    %eax, %eax      # Сложить с регистром %eax c %eax и записать в %eax (2 * i)
        addl    $1, %eax        # Добавить единицу туда же (2 * i + 1)
        movl    %eax, -44(%ebp) # Записать в память значение 2 * i + 1
        fildl   -44(%ebp)       # Загрузить целое число 2 * i + 1 в стек
        fld1                    # Загрузить константу +1.0 в стек
        fdivp   %st, %st(1)     # Деление вещественного числа с выталкиванием(1 / (2 * i + 1))
        fstpt   -36(%ebp)       # Записать и вытолкнуть вещественное число (сосчитали long double appendix)
        fildl   -24(%ebp)       # Загрузить целое число (i)              
        leal    -8(%esp), %esp  # Загрузить адрес %esp-8 в регистр %esp
        fstpl   (%esp)          # Записать и вытолкнуть вещественное число
        fld1                    # Загрузить число +1.0
        fchs                    # Смена знака числа (-1.0)
        leal    -8(%esp), %esp  # Загрузить адрес %esp-8 в регистр %esp
        fstpl   (%esp)          # Записать и вытолкнуть вещественное число
        call    pow             # Вызов подпрограммы pow
        addl    $16, %esp       # Увеличить регистр %esp на 16
        fldt    -36(%ebp)       # Загрузить вещественное число (appendix)
        fmulp   %st, %st(1)     # Умножение вещественного числа с выталкиванием (appedix * pow(-1, i))
        fldt    -20(%ebp)       # Загрузить вещественное число appedix * pow(-1, i)
        faddp   %st, %st(1)     # Сложение с вещественным числом с выталкиванием(pi += appedix * pow(-1, i))
        fstpt   -20(%ebp)       # Записать значение pi в память
        addl    $1, -24(%ebp)   # Увеличить i на 1
        jmp     .L3             # Начать заново
.L2:
        fldt    -20(%ebp)       # Загрузить вещественное число pi  
        fldt    .LC3            # Загрузить вещественные числа .LC3
        fmulp   %st, %st(1)     # Умножить pi и 4
        fstpt   -20(%ebp)       # Записать значение pi * 4 в память
        fldt    -20(%ebp)       # Загрузить вещественное число pi * 4
        leave                   # Выход из процедуры  
        ret                     # Возврат из подпрограммы
main:
        leal    4(%esp), %ecx   # Поместить в %ecx адрес предыдущего элемента в стеке
        andl    $-16, %esp      # Выравнить указатель по границе 16 байт
        pushl   -4(%ecx)        # Добавить в стек указатель на вершину предыдущего стека (%ecx - 4 = %esp)
        pushl   %ebp            # Добавить в стек указатель на базу предыдущего стека
        movl    %esp, %ebp      # Создать новый стек (база нового стека = вершина прошлого стека)
        pushl   %ecx            # Добавить в стек %ecx 
        subl    $20, %esp       # Сдвинуть вершнину стека на 20 байт (зарезервировать место под локальные переменные)
        movl    $1000000, -12(%ebp)     # Сохранить 1000000 в %ebp - 12 (N = 1000000)
        subl    $12, %esp       # Вычесть из %esp 12
        pushl   -12(%ebp)       # Добавить в стек %ebp - 12
        call    LeibnizFormula(int)     # Вызов подпрограммы LeibnizFormula
        addl    $16, %esp       # Добавить к %esp 16
        fstpt   -24(%ebp)       # Загрузить вещественное число из %ebp - 24 (pi)
        movl    $0, %eax        # %eax = 0 (return 0)
        movl    -4(%ebp), %ecx  # %ecx = %ebp - 4
        leave                   # Выход из процедуры
        leal    -4(%ecx), %esp  # %esp = %ecx - 4 = %ebp - 8
        ret                     # Возврат из подпрограммы
.LC3:                           # Константы, высчитанные компилятором
        .long   0
        .long   -2147483648
        .long   16385