gcc 10.2 -O2 -S -m32

LeibnizFormula(int):            # Начало функции LeibnizFormula
        pushl   %esi            # Положить в стек индекс источника (int n)               
        pushl   %ebx            # Сохранить значение %ebx
        subl    $20, %esp       # Сместить вершину стека на 20 байтов (зарезервировать место под локальные переменные)
        movl    32(%esp), %esi  # %esi = %esp + 32
        testl   %esi, %esi      # Проверка на ноль, если не ноль, то флаг ZF = 0
        jle     .L14            # Переход, если меньше или равно (ZF = 0) (n = 0 значит считать ничего не нужно)
        xorl    %ebx, %ebx      # Обнулить %ebx (int i = 0)
        fldz                    # Загрузить число 0.0 (pi = 0)
.L13:
        movl    %ebx, 12(%esp)  # %esp + 12 = %ebx (записать i в стек)
        subl    $8, %esp        # Сместить вершину стека на 8 байт (зарезервировать место под локальные переменные)
        fstpt   8(%esp)         # Записать и вытолкнуть вещественное число
        fildl   20(%esp)        # Загрузить целое число
        fstpl   (%esp)          # Записать и вытолкнуть вещественное число
        pushl   $-1074790400    # Добавить в стек -1 (0xFFFFFFFBFF00000) 
        pushl   $0              # Добавить в стек 0       
        call    pow             # Вызов подпрограммы pow
        leal    1(%ebx,%ebx), %eax      # %eax = 2 * %ebx + 1 (2 * i + 1)   
        addl    $1, %ebx        # %ebx += 1
        movl    %eax, 28(%esp)  # %esp + 28 = %eax
        fildl   28(%esp)        # Загрузить целое число
        fdivrs  .LC2            # Обратное деление вещественного числа (appendix = 1 / (2 * i + 1))
        fmulp   %st, %st(1)     # Умножение вещественного числа с выталкиванием (appendix * pow(-1, i))
        fldt    16(%esp)        # Загрузить вещественное число appendix * pow(-1, i) 
        addl    $16, %esp       # %esp += 16
        faddp   %st, %st(1)     # Сложение с вещественным числом с выталкиванием (pi += appendix * pow(-1, i))
        cmpl    %ebx, %esi      # Сравнение(i и n). Если равно, то флаг ZF = 1
        jne     .L13            # Переход, если не равно (ZF = 0) (i < n)
        fmuls   .LC3            # Умножить на 4 (pi *= 4)
        addl    $20, %esp       # Вернуть указатель на предыдущую вершину
        popl    %ebx            # Получить сохраненное значение %ebx
        popl    %esi            # Получить сохраненный индекс источника
        ret                     # Возврат из подпрограммы
.L14:
        addl    $20, %esp       # Вернуть указатель на предыдущую вершину
        fldz                    # Загрузить число 0.0 (int i = 0)
        popl    %ebx            # Получить сохраненное значение %ebx
        popl    %esi            # Получить сохраненный индекс источника
        ret                     # Возврат из подпрограммы
main:
        leal    4(%esp), %ecx   # %ecx = %esp + 4 (адресс прошлой вершины стека)
        andl    $-16, %esp      # Выравнить указатель ???
        pushl   -4(%ecx)        # Добавить в стек указатель на вершину предыдущего стека (%ecx - 4 = %esp)
        pushl   %ebp            # Добавить в стек указатель на базу предыдущего стека
        movl    %esp, %ebp      # Создать новый стек (база нового стека = вершина прошлого стека)
        pushl   %ecx            # Добавить в стек %ecx (указатель *argv[])
        subl    $16, %esp       # Сдвинуть вершнину стека на 16 байт (зарезервировать место под локальные переменные)
        pushl   $1000000        # Добавить в стек 1000000 (N = 1000000)
        call    LeibnizFormula(int)     # Вызов функции LeibnizFormula
        fstp    %st(0)          # Записать и вытолкнуть вещественное число (pi)
        movl    -4(%ebp), %ecx  # %ecx = %ebp - 4
        addl    $16, %esp       # Сместить вершину стека на 16 (вернуть к предыдущему занчению)
        xorl    %eax, %eax      # Обнулить %eax
        leave                   # Выход из процедуры
        leal    -4(%ecx), %esp
        ret                     # Возврат из подпрограммы
.LC2:                           # Константы, высчитанные компилятором
        .long   1065353216      # 1
.LC3:
        .long   1082130432      # 4